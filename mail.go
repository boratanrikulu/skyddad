package main

import (
	"crypto/rand"
	"fmt"
)

func LogIn(username string, password string) User {
  user := User {}
  db.Where("username = ? AND password = ?", username, password).First(&user)
  return user
}

func SingUp(username string, password string) (bool, User) {
  user := User{
    Username: username,
    Password: password,
  }
  db.Create(&user)
  return !db.NewRecord(user), user
}

func SendMail(from User, to User, body string, keyFromUser string) (bool, Mail) {
  if len(keyFromUser) == 0 || len(keyFromUser) == 32 || len(keyFromUser) == 64 {
    symmetricKey := SymmetricKey{}
    setSymmetricKey(&symmetricKey, keyFromUser, from, to)

    mail := Mail {
      From: from,
      To: to,
    }

    if symmetricKey.Key != ""  {
      body = encrypt(body, symmetricKey.Key)
      mail.SymmetricKey = symmetricKey
      mail.IsEncrypted = true
      } else {
        mail.IsEncrypted = false
      }
      mail.Body = body

      db.Create(&mail)
      return !db.NewRecord(mail), mail
  } else {
    panic("Key length must be 32 or 64.")
  }
}

func Mails(user User, take string) []Mail {
  encryptedMails := []Mail{}
  db.Order("created_at desc").
     Limit(take).
     Model(&user).
     Association("Mails").
     Find(&encryptedMails)

  decryptedMails := decryptMails(encryptedMails)
  return decryptedMails
}

func setSymmetricKey(symmetricKey *SymmetricKey, keyFromUser string, from User, to User) {
  symmetricKey.SenderRefer = from.ID
  symmetricKey.ReceiverRefer = to.ID

  if keyFromUser == "" {
    key := make([]byte, 32)
    rand.Read(key)
    keyString := fmt.Sprintf("%x", key)
    db.Where(SymmetricKey{
            SenderRefer: from.ID,
            ReceiverRefer: to.ID,
            IsAutoGenerated: true,
          }).
     Attrs(SymmetricKey{
            Key: keyString,
          }).
     FirstOrCreate(&symmetricKey)
  } else {
    db.Where(SymmetricKey{
            SenderRefer: from.ID,
            ReceiverRefer: to.ID,
            Key: keyFromUser,
          }).
     FirstOrCreate(&symmetricKey)
  }
}

func decryptMails(mails []Mail) []Mail {
  decryptedMails := []Mail{}

  for _, mail := range mails {
    if mail.IsEncrypted == true {
      symmetricKey := SymmetricKey{}
      db.Model(&mail).Association("SymmetricKey").Find(&symmetricKey)
      mail.Body = decrypt(mail.Body, symmetricKey.Key)
      decryptedMails = append(decryptedMails, mail)
    } else {
      decryptedMails = append(decryptedMails, mail)
    }
  }
  return decryptedMails
}
